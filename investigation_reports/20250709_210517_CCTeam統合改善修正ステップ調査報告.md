# CCTeam統合改善修正ステップ調査報告書

作成日時: 2025年01月09日 21時05分17秒 (JST)
作成者: CCTeam
バージョン: 0.0.7

---

## 📋 概要

ユーザーフィードバックに基づき、CCTeamシステムの包括的な改善計画を策定しました。主な改善点は以下の通りです：

1. tmuxセッションの統合（Bossエージェントの一元化）
2. Git worktree並列開発のマニュアル作成と自動化計画
3. Docker認証後の組織的開発の確保
4. tmuxペイン管理機能の実装（exit対策、動的追加）

## 🔍 現状分析と改善要件

### 1. tmuxセッション統合の必要性

#### 現状の問題点
```
現在の実装:
- ccteam-boss セッション（Boss | Gemini）
- ccteam セッション（Boss | Worker1 | Worker2 | Worker3）
→ 2つの独立したBossが存在し、指示が分散
```

#### 参考実装（Claude-Code-Communication）
```
president セッション（president）
multiagent セッション（boss1 | worker1 | worker2 | worker3）
→ boss1が唯一のリーダーとして機能
```

### 2. Git worktree並列開発の手動プロセス

現在は完全に手動での操作が必要：
- worktree作成
- 各worktreeでのCCTeam起動
- タスクの振り分け

### 3. tmuxペイン管理の脆弱性

- エージェントがexitすると画面レイアウトが崩壊
- 再起動時に元のレイアウトが復元されない
- 動的なエージェント追加ができない

## 💡 包括的改善計画

### 改善点1: tmuxセッション統合アーキテクチャ

#### 新しいセッション構成
```bash
# 統合されたBossアーキテクチャ
ccteam セッション:
┌─────────────┬─────────────┐
│    Boss     │   Worker1   │
│  (統合版)   │             │
├─────────────┼─────────────┤
│   Worker2   │   Worker3   │
│             │             │
└─────────────┴─────────────┘

ccteam-support セッション:
┌──────────────────────────┐
│        Gemini            │
└──────────────────────────┘
```

#### 実装方法
```bash
#!/bin/bash
# scripts/setup-unified.sh

# 既存セッションをクリーンアップ
tmux kill-session -t ccteam 2>/dev/null
tmux kill-session -t ccteam-boss 2>/dev/null
tmux kill-session -t ccteam-support 2>/dev/null

# 統合メインセッション作成
tmux new-session -d -s ccteam -n main

# 2x2レイアウト作成
tmux split-window -h -t ccteam:main
tmux split-window -v -t ccteam:main.0
tmux split-window -v -t ccteam:main.1

# ペインに名前を設定（tmux 3.0+）
tmux select-pane -t ccteam:main.0 -T "Boss"
tmux select-pane -t ccteam:main.1 -T "Worker1"
tmux select-pane -t ccteam:main.2 -T "Worker2"
tmux select-pane -t ccteam:main.3 -T "Worker3"

# サポートセッション（Gemini用）
tmux new-session -d -s ccteam-support -n gemini
tmux select-pane -t ccteam-support:gemini.0 -T "Gemini"

echo "✅ 統合セッション構成完了"
```

### 改善点2: Git worktree並列開発マニュアルと自動化

#### 手動並列開発マニュアル
```bash
#!/bin/bash
# scripts/worktree-parallel-manual.sh

echo "=== CCTeam Git Worktree 並列開発マニュアル ==="
echo ""
echo "📋 前提条件:"
echo "- 複数の独立したタスクが存在する"
echo "- タスク間でコード競合の可能性がある"
echo ""
echo "🔧 手順:"
echo ""
echo "1. タスクの分析と分岐判断"
echo "   - タスクA: ユーザー認証機能"
echo "   - タスクB: 決済システム統合"
echo "   → 両タスクは独立しているため並列可能"
echo ""
echo "2. Worktreeの作成"
cat << 'EOF'
# メインで実行
git worktree add ../worktrees/feature-auth feature/auth
git worktree add ../worktrees/feature-payment feature/payment
EOF
echo ""
echo "3. 各Worktreeでチーム起動"
cat << 'EOF'
# ターミナル1
cd ../worktrees/feature-auth
./scripts/launch-ccteam.sh
# BOSSに指示: "ユーザー認証機能を実装してください"

# ターミナル2
cd ../worktrees/feature-payment
./scripts/launch-ccteam.sh
# BOSSに指示: "決済システム統合を実装してください"
EOF
echo ""
echo "4. 進捗管理"
echo "   - 各worktreeのBOSSが独立して作業を管理"
echo "   - 定期的にメインブランチにマージ"
echo ""
echo "5. 統合"
cat << 'EOF'
# 各worktreeで作業完了後
cd ../worktrees/feature-auth
git push origin feature/auth

cd ../../CCTeam
git worktree remove ../worktrees/feature-auth
EOF
```

#### 自動並列判断システム（将来実装）
```python
#!/usr/bin/env python3
# scripts/auto_parallel_analyzer.py

import json
from pathlib import Path
from typing import List, Dict, Tuple

class ParallelAnalyzer:
    """タスクの並列可能性を分析"""
    
    def analyze_tasks(self, tasks: List[Dict]) -> List[Tuple[str, List[str]]]:
        """
        タスクを分析して並列実行可能なグループに分類
        
        Returns:
            List of (branch_name, task_ids)
        """
        parallel_groups = []
        
        # 依存関係とファイル競合を分析
        for i, task in enumerate(tasks):
            # 影響ファイルを取得
            affected_files = self._get_affected_files(task)
            
            # 既存グループとの競合チェック
            can_parallel = True
            for group_name, group_tasks in parallel_groups:
                if self._has_conflict(task, group_tasks, affected_files):
                    can_parallel = False
                    break
            
            if can_parallel:
                # 新しい並列グループを作成
                branch_name = f"parallel-{task['id']}"
                parallel_groups.append((branch_name, [task['id']]))
        
        return parallel_groups
    
    def _get_affected_files(self, task: Dict) -> List[str]:
        """タスクが影響するファイルを推定"""
        # タスク説明からファイルパスを抽出
        # 実装例: NLPや正規表現で解析
        return []
    
    def _has_conflict(self, task: Dict, group_tasks: List[str], 
                      affected_files: List[str]) -> bool:
        """ファイル競合の有無をチェック"""
        # 実装例: Git履歴やコード依存関係を分析
        return False

# 自動実行スクリプト
def auto_create_worktrees(task_file: str):
    """タスクファイルから自動的にworktreeを作成"""
    analyzer = ParallelAnalyzer()
    
    with open(task_file, 'r') as f:
        tasks = json.load(f)
    
    parallel_groups = analyzer.analyze_tasks(tasks)
    
    for branch_name, task_ids in parallel_groups:
        print(f"Creating worktree: {branch_name} for tasks: {task_ids}")
        # git worktree add コマンドを実行
        # CCTeamを起動
        # タスクを自動的にBOSSに送信
```

### 改善点3: Docker認証後の組織的開発の保証

#### Docker認証後の動作確認
```yaml
# docker-compose-ccteam.yml
version: '3.8'

services:
  boss:
    image: claude-agent:latest
    container_name: ccteam-boss
    volumes:
      - ./claude_config/boss:/root/.claude
      - ./:/workspace
    working_dir: /workspace
    networks:
      - claude-net
    command: |
      bash -c "
        echo 'Boss エージェント起動完了';
        echo '認証状態: $(claude --version && echo '✅ 認証済み' || echo '❌ 未認証')';
        # エージェント間通信テスト
        while true; do
          sleep 60
          echo 'Worker状態確認中...'
          # 実際の通信ロジックをここに実装
        done
      "

  worker1:
    image: claude-agent:latest
    container_name: ccteam-worker1
    volumes:
      - ./claude_config/worker1:/root/.claude
      - ./:/workspace
    working_dir: /workspace
    networks:
      - claude-net
    depends_on:
      - boss
    command: |
      bash -c "
        echo 'Worker1 エージェント起動完了';
        echo '認証状態: $(claude --version && echo '✅ 認証済み' || echo '❌ 未認証')';
        # Bossからの指示待機
        tail -f /dev/null
      "

  # worker2, worker3も同様

  # エージェント間通信ブリッジ
  communication-bridge:
    image: alpine:latest
    container_name: ccteam-bridge
    volumes:
      - ./communication:/var/communication
    networks:
      - claude-net
    command: |
      sh -c "
        # 通信用の名前付きパイプを作成
        mkfifo /var/communication/boss-to-worker1
        mkfifo /var/communication/worker1-to-boss
        # 他のペアも作成
        tail -f /dev/null
      "

networks:
  claude-net:
    driver: bridge
```

**回答：はい、組織的開発は可能です。**
- 各エージェントは認証済み状態で起動
- 共有ボリュームでコードベースにアクセス
- カスタムネットワークで相互通信可能

### 改善点4: tmuxペイン管理機能

#### 動的ペイン復元・追加システム
```bash
#!/bin/bash
# scripts/tmux-pane-manager.sh

# ペイン状態を保存
save_pane_layout() {
    local session=$1
    tmux list-panes -t $session -F "#{pane_index}:#{pane_title}:#{pane_width}x#{pane_height}" > ~/.ccteam/pane_layout_$session.txt
}

# ペインを復元
restore_pane_layout() {
    local session=$1
    local layout_file=~/.ccteam/pane_layout_$session.txt
    
    if [[ ! -f $layout_file ]]; then
        echo "レイアウトファイルが見つかりません"
        return 1
    fi
    
    # 現在のペイン数を確認
    current_panes=$(tmux list-panes -t $session | wc -l)
    expected_panes=$(wc -l < $layout_file)
    
    if [[ $current_panes -lt $expected_panes ]]; then
        echo "ペインが不足しています。復元を開始..."
        
        # 不足分のペインを作成
        while [[ $current_panes -lt $expected_panes ]]; do
            if [[ $current_panes -eq 1 ]]; then
                tmux split-window -h -t $session
            elif [[ $current_panes -eq 2 ]]; then
                tmux split-window -v -t $session.0
            elif [[ $current_panes -eq 3 ]]; then
                tmux split-window -v -t $session.1
            fi
            ((current_panes++))
        done
        
        # 均等なレイアウトに再配置
        tmux select-layout -t $session tiled
    fi
}

# 単一エージェントを追加
add_single_agent() {
    local session=$1
    local agent_type=$2  # worker4, specialist1, etc.
    
    # 現在のペイン数を確認
    current_panes=$(tmux list-panes -t $session | wc -l)
    
    # 新しいペインを作成
    if [[ $current_panes -eq 4 ]]; then
        # 2x2レイアウトの場合、3x2に拡張
        tmux split-window -h -t $session.3
        tmux select-layout -t $session tiled
    else
        # それ以外は最後に追加
        tmux split-window -t $session
        tmux select-layout -t $session tiled
    fi
    
    # 新しいペインにエージェントを設定
    new_pane_index=$((current_panes))
    tmux select-pane -t $session.$new_pane_index -T "$agent_type"
    
    echo "✅ $agent_type を追加しました（ペイン: $new_pane_index）"
}

# exitフック（自動復元）
setup_exit_hook() {
    cat > ~/.ccteam/pane_exit_hook.sh << 'EOF'
#!/bin/bash
# tmuxペインが終了した時に自動実行されるフック

SESSION=$(tmux display-message -p '#S')
if [[ $SESSION == "ccteam"* ]]; then
    # レイアウトを復元
    /path/to/scripts/tmux-pane-manager.sh restore $SESSION
    
    # エージェントを再起動
    PANE_TITLE=$(tmux display-message -p '#{pane_title}')
    case $PANE_TITLE in
        "Boss")
            tmux send-keys "claude" C-m
            ;;
        "Worker"*)
            tmux send-keys "claude" C-m
            ;;
    esac
fi
EOF
    
    # tmuxの設定に追加
    echo "set-hook -g pane-died 'run-shell ~/.ccteam/pane_exit_hook.sh'" >> ~/.tmux.conf
}

# メイン処理
case "$1" in
    "save")
        save_pane_layout "$2"
        ;;
    "restore")
        restore_pane_layout "$2"
        ;;
    "add")
        add_single_agent "$2" "$3"
        ;;
    "setup-hooks")
        setup_exit_hook
        ;;
    *)
        echo "Usage: $0 {save|restore|add|setup-hooks} [session] [agent_type]"
        ;;
esac
```

## 📈 実装計画

| フェーズ | 内容 | 期間 | 優先度 |
|---------|------|------|--------|
| Phase 1 | tmuxセッション統合（Boss一元化） | 2日 | 高 |
| Phase 2 | tmuxペイン管理機能 | 3日 | 高 |
| Phase 3 | worktree並列マニュアル作成 | 1日 | 高 |
| Phase 4 | Docker認証システム実装 | 1週間 | 中 |
| Phase 5 | worktree自動並列化 | 2週間 | 低 |

## 🚀 即時実行可能なアクション

### 1. tmuxセッション統合
```bash
# 新しいsetup-unified.shを作成して実行
./scripts/setup-unified.sh
```

### 2. ペイン管理機能の有効化
```bash
# フックを設定
./scripts/tmux-pane-manager.sh setup-hooks

# レイアウトを保存
./scripts/tmux-pane-manager.sh save ccteam

# エージェント追加例
./scripts/tmux-pane-manager.sh add ccteam worker4
```

### 3. worktree並列開発の開始
```bash
# マニュアルに従って実行
./scripts/worktree-parallel-manual.sh

# 実際の並列開発
git worktree add ../worktrees/feature-x feature/x
cd ../worktrees/feature-x
./scripts/launch-ccteam.sh
```

## 📊 期待される成果

1. **統一されたBoss**: 指示の一元管理により混乱を防止
2. **堅牢なペイン管理**: exitしても自動復元、動的追加可能
3. **効率的な並列開発**: 明確なマニュアルと将来の自動化
4. **安定した認証**: Docker環境での確実な動作

## 📎 参考資料

- [Claude-Code-Communication実装](https://github.com/Akira-Papa/Claude-Code-Communication)
- [tmux hooks documentation](https://github.com/tmux/tmux/wiki/Hooks)
- [Git Worktree Best Practices](https://git-scm.com/docs/git-worktree)

---

## 更新履歴

- 2025年01月09日 21時05分17秒 (JST): 初版作成